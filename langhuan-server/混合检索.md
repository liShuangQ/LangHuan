研究动态构建是否可行？ 



删除 numFilter 模式

RAGWITHTOPK 改为 { 10 , 10} 表示 { bm25检索的topk, 向量检索的topk }，实际计算权重时将结果相加，建议bm25检索的topk的小点

LINEARWEIGHTING 中添加针对 bm25检索的权重

# 1
```sql
CREATE INDEX IF NOT EXISTS idx_vector_store_rag_content_bm25 
ON vector_store_rag 
USING gin (to_tsvector('chinese', content));
  -- 'english'可替换为其他语言（如'chinese'）
-- 若需支持中文，需先安装中文分词插件（如zhparser），再替换为对应的配置（如'chinese'）。
```

```sql
-- BM25检索（基于content字段的关键词匹配） 
SELECT 
  id, 
  content, 
  ts_rank(to_tsvector('chinese', content), to_tsquery('chinese', '你的查询关键词')) AS bm25_score
FROM vector_store_rag
WHERE to_tsvector('chinese', content) @@ to_tsquery('chinese', '你的查询关键词')
ORDER BY bm25_score DESC
LIMIT 100;

-- 2. 向量检索（基于embedding字段的语义相似度） -- 使用springai的向量检索
SELECT 
  id, 
  content, 
  1 - (embedding <=> '[你的查询向量]') AS vector_score  -- 将余弦距离转为相似度得分（0-1）
FROM vector_store_rag
ORDER BY embedding <=> '[你的查询向量]'  -- 按余弦距离升序（越近越相似）
LIMIT 100;
```
# 2
在应用层融合两种结果
由于 SQL 中直接融合两种检索结果较复杂，建议在应用层（如 Python）实现：
分别执行上述两个 SQL，获取 BM25 结果（带bm25_score）和向量结果（带vector_score）。
对两种得分进行归一化（如都转换为 0-1 范围）。
按权重融合得分（例如：final_score = 0.4*bm25_score + 0.6*vector_score）。
去重后按final_score排序，返回最终结果。

